#!/bin/bash

function isFloat() {
if [ $# -ne 1 ]; then
	echo false
	return 1
fi

param=$1

if $(isNumber $param); then
	if [ -n "$(echo "$param" | grep '\.\|[Ee]')" ]; then
		echo true
	else
		echo false
	fi
else
	echo false
fi

return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
}

function isInteger() {
if [ $# -ne 1 ]; then
	echo false
	return 1
fi

param=$1

if $(isNumber $param); then
	if [ -z "$(echo "$param" | grep '\.')" ]; then
		echo true
	else
		echo false
	fi
else
	echo false
fi

return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
}

function isNumber() {
if [ $# -ne 1 ]; then
	echo false
	return 1
fi

param=$1

res=$(echo $param | grep -x '^[-+]\?[0-9]*\.\?[0-9]*\([Ee][-+]\?[0-9]\+\)\?$') # grep -x forces a line match (POSIX compliant)
if [ -n "$res" ]; then # test if $res return a non-zero string (number is valid)
	sciweird=$(echo "$res" | grep '^[-+]\?\.\?[Ee]\|[Ee]$') # check if resulting number doesn't begin with [Ee]
	if [ -z "$sciweird" ]; then
		echo true
	else
		echo false
	fi
else
	echo false
fi

return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
}

function isScientificNotation() {
if [ $# -ne 1 ]; then
	echo false
	return 1
fi

param=$1

if $(isNumber $param); then
	if [ -n "$(echo "$param" | grep '[Ee]')" ]; then
		echo true
	else
		echo false
	fi
else
	echo false
fi

return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
}

function normalizeFloat() {
if [ $# -ne 1 ]; then
	return 1
fi

param=$1
if ! $(isFloat $param); then
	return 2
fi

if $(isScientificNotation $param); then
	return 3
fi

# Chosen method: split the number at the floating point:
# 1. The integer part is normalized by using "normalizeInteger"
# 2. The float part is normalized by removing the trailing zeros.
#    If the float part is omitted, a zero is added after the floating point

# Splitting
integer=$(echo "$param" | cut -d "." -f 1)
float=$(echo "$param" | cut -d "." -f 2)

# Normalizing integer part
inorm=$(normalizeInteger $integer)

# Normalizing float part
fnorm=$(echo "$float" | sed 's/0*$//')
# If the number is just a sequency of zeros , the last sed will remove all of them.
# If the float part is also empty, this check solves that by setting fnorm=0
if [ -z "$fnorm" ]; then 
	fnorm=0
fi

res="$inorm.$fnorm"

echo $res
return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
# 2 - Input is not float
# 3 - Scientific notation numbers is not allowed, although, they are float! 
}

function normalizeInteger() {
if [ $# -ne 1 ]; then
	return 1
fi

param=$1
if ! $(isInteger $param); then
	return 2
fi

signal=$(echo "$param" | grep "^[+-]" | cut -c 1)

if [ -z "$signal" ]; then
	number=$param
else
	number=$(echo "$param" | sed "s/^$signal//")
fi

# Remove number's leading zeros
res=$(echo "$number" | sed 's/^0*//')
# If the number is just a sequency of zeros, the last sed will remove all of them.
# If it is also empty, this check solves that by setting res=0 
if [ -z "$res" ]; then
	res=0
fi

# Place again the "-" before negative numbers. The "+" is supressed in positive ones. 
if [ "$signal" == "-" ]; then
	if [ $res -ne 0 ]; then # If the number is zero but is preceded by "-", the signal is supressed in this check
		res=-$res
	fi
fi

echo $res
return 0

# Return codes
# 0 - OK
# 1 - Not enough parameters
# 2 - Input is not integer
} 

